---
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardFooter } from '@/components/ui/card';
const API_BASE = import.meta.env.PUBLIC_API_BASE || '/api';
---

<Card className="border-0 shadow-lg bg-gradient-to-br from-white to-gray-50 hover:shadow-xl transition-all duration-300">
	<CardHeader className="pb-4">
		<div class="flex items-center space-x-3">
			<div class="w-8 h-8 bg-gradient-to-r from-indigo-500 to-purple-600 rounded-full flex items-center justify-center text-white font-bold text-sm">2</div>
			<h2 class="text-2xl font-bold text-gray-800">Avatar Creation</h2>
		</div>
		<p class="text-gray-600 mt-2">Design your AI assistant's personality and appearance</p>
	</CardHeader>
	<CardContent className="space-y-8">
		<!-- Character Description -->
		<div class="space-y-4 mt-8">
			<label class="text-sm font-medium text-black-700">Describe your ideal avatar *</label>
			<p class="text-sm text-gray-500">Be specific about appearance, personality, and visual style. This will be used to generate consistent stickers.</p>
			<textarea 
				placeholder="e.g., A friendly tech-savvy sloth wearing round glasses, blue hoodie, and a warm smile. Has a modern, clean aesthetic with soft rounded features. Loves helping people and has an approachable, professional demeanor..."
				class="w-full px-4 py-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none transition-all h-24 resize-none hover:border-gray-300"
				id="avatarCreationDescription"
			></textarea>
		</div>


		<!-- Color Palette -->
		<div class="space-y-4 mt-8">
			<label class="text-sm font-medium text-black-700">Avatar Color Palette</label>
			<p class="text-sm text-gray-500">Choose 4 colors for your avatar's visual design (optional)</p>
			<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4" id="colorPalette">
				{[
					{ name: 'Primary', id: 'color1', value: '#3B82F6' },
					{ name: 'Secondary', id: 'color2', value: '#8B5CF6' },
					{ name: 'Accent', id: 'color3', value: '#10B981' },
					{ name: 'Neutral', id: 'color4', value: '#6B7280' }
				].map((color) => (
					<div class="space-y-2 p-3  rounded-lg ">
						<label class="text-xs font-medium text-gray-600">{color.name}</label>
						<div class="flex items-center gap-3">
							<input 
								type="color" 
								id={color.id}
								value={color.value}
								class="w-14 h-14 rounded-lg border-2 border-gray-200 cursor-pointer hover:border-gray-300 transition-colors"
							/>
							<input 
								type="text" 
								value={color.value}
								class="w-full px-3 py-2 text-sm border border-gray-200 rounded focus:ring-1 focus:ring-indigo-500 focus:border-transparent outline-none cursor-pointer hover:border-gray-300 transition-colors"
								readonly
								data-color-picker={color.id}
							/>
						</div>
					</div>
				))}
			</div>
		</div>

		<!-- Avatar Personality -->
		<div class="space-y-4 mt-8">
			<label class="text-sm font-medium text-black-700">Avatar Personality</label>
			<p class="text-sm text-gray-500">Choose the personality that best fits your avatar. This affects how they look, act, and communicate in stickers.</p>
			<div class="grid grid-cols-1 md:grid-cols-2 gap-3" id="personalitySelection">
				{[
					{ name: 'Friendly Helper', icon: '😊', selected: true, description: 'Warm, approachable, always ready to help' },
					{ name: 'Professional Expert', icon: '👔', selected: false, description: 'Formal, knowledgeable, composed' },
					{ name: 'Casual Companion', icon: '😌', selected: false, description: 'Relaxed, easy-going, laid back' },
					{ name: 'Energetic Enthusiast', icon: '🚀', selected: false, description: 'Excited, dynamic, high-energy' },
					{ name: 'Calm Guide', icon: '🧘', selected: false, description: 'Serene, reassuring, peaceful' },
					{ name: 'Playful Friend', icon: '🎮', selected: false, description: 'Fun, entertaining, lighthearted' }
				].map((personality) => (
					<button 
						class={`p-4 rounded-lg border-2 transition-all text-left hover:scale-105 transform ${
							personality.selected 
								? 'border-indigo-500 bg-indigo-50 text-indigo-700 shadow-md' 
								: 'border-gray-200 hover:border-gray-300 text-gray-600 hover:shadow-sm'
						}`}
						data-personality={personality.name}
					>
						<div class="text-2xl mb-2">{personality.icon}</div>
						<div class="text-sm font-medium mb-1">{personality.name}</div>
						<div class="text-xs text-gray-500">{personality.description}</div>
					</button>
				))}
			</div>
		</div>

		<div class="grid md:grid-cols-2 gap-8 mt-8">
			<!-- Upload Section -->
			<div class="space-y-4">
				<h3 class="text-lg font-semibold text-gray-800">Reference Images (Recommended)</h3>
				<p class="text-sm text-gray-500">Upload up to 3 images that inspire your avatar design. These will be used as visual references to create a more accurate and personalized avatar.</p>
				
				<!-- Upload Area -->
				<div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-indigo-400 hover:bg-indigo-50 transition-all duration-300 cursor-pointer group" id="uploadArea">
					<svg class="w-12 h-12 text-gray-400 mx-auto mb-4 group-hover:text-indigo-500 transition-colors duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
					</svg>
					<p class="text-gray-600 mb-2 group-hover:text-indigo-600 transition-colors duration-300">Drag & drop images here</p>
					<p class="text-sm text-gray-500 group-hover:text-indigo-500 transition-colors duration-300">or click to browse</p>
					<input type="file" id="fileInput" accept="image/jpeg,image/jpg,image/png,image/svg+xml" multiple class="hidden" />
				</div>
				
				<!-- Uploaded Images Preview -->
				<div id="uploadedImages" class="space-y-3 hidden">
					<h4 class="text-sm font-medium text-gray-700">Uploaded Images</h4>
					<div id="imageList" class="space-y-2"></div>
				</div>
				
				<!-- Upload Progress -->
				<div id="uploadProgress" class="hidden">
					<div class="bg-gray-200 rounded-full h-2">
						<div id="progressBar" class="bg-indigo-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
					</div>
					<p id="progressText" class="text-sm text-gray-600 mt-1">Uploading...</p>
				</div>
				
				<div class="text-sm text-gray-500">
					<p>• <strong>Character references:</strong> Similar characters, mascots, or avatars you like</p>
					<p>• <strong>Style inspiration:</strong> Art styles, color schemes, or visual aesthetics</p>
					<p>• <strong>Facial features:</strong> Expressions, eye styles, or facial characteristics</p>
					<p>• Supported formats: JPG, PNG, SVG • Max file size: 10MB per image • Maximum 3 images allowed</p>
				</div>
			</div>
			
			<!-- Avatar Preview -->
			<div class="space-y-4 mt-8">
				<h3 class="text-lg font-semibold text-gray-800">Generate Your Avatar</h3>
				<div class="bg-gradient-to-br from-indigo-100 to-purple-100 rounded-2xl p-8 text-center">
					<div class="w-32 h-32 mx-auto bg-white rounded-2xl shadow-lg flex items-center justify-center mb-4">
						<img src="/dummy-sticker.webp" alt="Generated Avatar" class="w-24 h-24 rounded-xl" />
					</div>
					<p class="text-sm text-gray-600 mb-2">Your AI assistant avatar</p>
					<p class="text-xs text-gray-500 mb-4">Based on your description and brand</p>
					
					<!-- Call to Action -->
					<div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
						<div class="flex items-center justify-center mb-2">
							<svg class="w-5 h-5 text-yellow-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
							</svg>
							<p class="text-sm font-medium text-yellow-800">Important Step!</p>
						</div>
						<p class="text-xs text-yellow-700">Click the button below to generate your avatar. This is required for creating stickers!</p>
					</div>
					
					<Button variant="outline" size="lg" className="bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 hover:from-indigo-600 hover:via-purple-600 hover:to-pink-600 text-white border-0 shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200" id="regenerateAvatar">
						<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
						</svg>
						Generate Avatar
					</Button>
				</div>
			</div>
		</div>

	</CardContent>
</Card>

<!-- Save Button Outside Card -->
<div class="flex justify-end mt-6">
	<button 
		class="cursor-pointer inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-lg font-semibold transition-all disabled:pointer-events-none disabled:opacity-50 px-8 py-4 bg-purple-600 hover:bg-purple-700 text-white shadow-lg hover:shadow-xl transform hover:scale-105 duration-200"
		id="saveAvatarDesign"
	>
		<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
			<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
		</svg>
		Save Avatar Design
	</button>
</div>

<!-- Go Back Button -->
<div class="flex justify-center mt-4">
	<button 
		class=" cursor-pointer inline-flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors duration-200"
		id="goBackAvatarCreation"
	>
		<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
			<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
		</svg>
		Back to Brand Identity
	</button>
</div>

<div id="env-avatar" data-api-base={API_BASE} class="hidden"></div>

<script is:inline>
	document.addEventListener('DOMContentLoaded', function() {
		// Color picker synchronization
		const colorPickers = document.querySelectorAll('input[type="color"]');
		colorPickers.forEach(picker => {
			picker.addEventListener('input', function() {
				// Find the corresponding text input and update its value
				const textInput = this.parentElement.querySelector('input[type="text"]');
				if (textInput) {
					textInput.value = this.value;
				}
			});
		});

		// Make hex code inputs clickable to open color picker
		const hexInputs = document.querySelectorAll('input[data-color-picker]');
		hexInputs.forEach(hexInput => {
			hexInput.addEventListener('click', function() {
				const colorPickerId = this.dataset.colorPicker;
				const colorPicker = document.getElementById(colorPickerId);
				if (colorPicker) {
					colorPicker.click();
				}
			});
		});

		// Personality selection (single select)
		const personalityButtons = document.querySelectorAll('[data-personality]');
		personalityButtons.forEach(button => {
			button.addEventListener('click', function() {
				// Remove selection from all personality buttons
				personalityButtons.forEach(btn => {
					btn.classList.remove('border-indigo-500', 'bg-indigo-50', 'text-indigo-700', 'shadow-md');
					btn.classList.add('border-gray-200', 'text-gray-600');
				});
				
				// Add selection to clicked button
				this.classList.add('border-indigo-500', 'bg-indigo-50', 'text-indigo-700', 'shadow-md');
				this.classList.remove('border-gray-200', 'text-gray-600');
			});
		});

		// Regenerate avatar button
		const regenerateBtn = document.getElementById('regenerateAvatar');
		if (regenerateBtn) {
			regenerateBtn.addEventListener('click', async function() {
				// Disable button and show loading state
				this.disabled = true;
				this.innerHTML = `
					<svg class="w-4 h-4 mr-2 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
					</svg>
					Generating Avatar...
				`;
				
				try {
				// Get current form data
				const currentFormData = {
					avatarDescription: document.getElementById('avatarCreationDescription')?.value,
					personality: document.querySelector('[data-personality].border-indigo-500')?.dataset.personality,
					colorPalette: {
						primary: document.getElementById('color1')?.value,
						secondary: document.getElementById('color2')?.value,
						accent: document.getElementById('color3')?.value,
						neutral: document.getElementById('color4')?.value
					},
					referenceImages: uploadedImages
				};

					// Get centralized state for brand identity
					const state = window.stickitGroupState || {};
					const brandIdentity = state.input?.brandIdentity || {};
					const avatarCreation = {
						description: currentFormData.avatarDescription,
						personality: currentFormData.personality,
						colorPalette: currentFormData.colorPalette,
						referenceImages: currentFormData.referenceImages
					};

					// Check if we have minimum required data
					if (!brandIdentity.avatarDescription && !avatarCreation.description) {
						throw new Error('Please provide at least a description of your avatar in either the Brand Identity or Avatar Creation section.');
					}

					// Get group ID from URL params
					const params = new URLSearchParams(window.location.search);
					const groupId = params.get('groupId');

					// Prepare request payload
					const payload = {
						brandIdentity,
						avatarCreation,
						groupId
					};

					// Get API base URL
					const envEl = document.getElementById('env-avatar');
					const API_BASE = (envEl && envEl.getAttribute('data-api-base')) || 'http://localhost:8002';

					console.log('🚀 Sending avatar generation request to API...');

					// Call the API
					const response = await fetch(`${API_BASE}/generate-avatar`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
						},
						credentials: 'include',
						body: JSON.stringify(payload)
					});

					if (!response.ok) {
						const errorData = await response.json();
						console.error('❌ API request failed:', errorData);
						throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
					}

					const result = await response.json();
					console.log('✅ Avatar generation successful:', {
						filename: result.filename,
						size: result.size,
						generationTime: result.generationTime
					});

					// Store the generated avatar data
					generatedAvatar = {
						filename: result.filename,
						url: result.url,
						size: result.size,
						generationTime: result.generationTime,
						generatedAt: new Date().toISOString()
					};
					console.log('💾 Generated avatar data stored:', generatedAvatar);

					// Update the avatar preview image
					const avatarImage = document.querySelector('.w-24.h-24.rounded-xl');
					if (avatarImage && result.url) {
						console.log('🖼️ Updating avatar preview with generated image...');
						avatarImage.src = result.url;
						avatarImage.alt = 'Generated Avatar';
						
						// Add error handling for image loading
						avatarImage.onerror = function() {
							console.error('❌ Failed to load avatar image:', result.url);
							alert('Generated avatar image could not be loaded. Please try again.');
						};
						
						avatarImage.onload = function() {
							console.log('✅ Avatar image loaded and displayed successfully');
						};
					} else {
						console.error('❌ No avatar image element found or no URL in result');
					}

					// Show success message
					this.innerHTML = `
						<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
						</svg>
						Avatar Generated!
					`;
					
					// Add a visual indicator that avatar is ready to save
					const avatarPreview = document.querySelector('.bg-gradient-to-br.from-indigo-100.to-purple-100');
					if (avatarPreview) {
						avatarPreview.classList.add('ring-2', 'ring-green-400', 'ring-opacity-50');
						
						// Update the call-to-action section to show success
						const callToAction = avatarPreview.querySelector('.bg-yellow-50');
						if (callToAction) {
							callToAction.className = 'bg-green-50 border border-green-200 rounded-lg p-4 mb-4';
							callToAction.innerHTML = `
								<div class="flex items-center justify-center mb-2">
									<svg class="w-5 h-5 text-green-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
									</svg>
									<p class="text-sm font-medium text-green-800">Avatar Generated Successfully!</p>
								</div>
								<p class="text-xs text-green-700">Your avatar is ready! You can now proceed to create stickers.</p>
							`;
						}
						
						setTimeout(() => {
							avatarPreview.classList.remove('ring-2', 'ring-green-400', 'ring-opacity-50');
						}, 5000);
					}

					// Reset button after 2 seconds
				setTimeout(() => {
						this.innerHTML = `
							<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
							</svg>
							Regenerate Avatar
						`;
						this.disabled = false;
					}, 2000);

				} catch (error) {
					console.error('Avatar generation failed:', error);
					
					// Show error state
					this.innerHTML = `
						<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
						</svg>
						Generation Failed
					`;

					// Show error message to user
					alert(`Failed to generate avatar: ${error.message}`);

					// Reset button after 3 seconds
					setTimeout(() => {
						this.innerHTML = `
							<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
							</svg>
							Generate Avatar
						`;
						this.disabled = false;
					}, 3000);
				}
			});
		}

		// Save button
		const saveButton = document.getElementById('saveAvatarDesign');
		if (saveButton) {
			saveButton.addEventListener('click', async function() {
				// Get form data
				const formData = {
					avatarDescription: document.getElementById('avatarCreationDescription')?.value,
					personality: document.querySelector('[data-personality].border-indigo-500')?.dataset.personality,
					colorPalette: {
						primary: document.getElementById('color1')?.value,
						secondary: document.getElementById('color2')?.value,
						accent: document.getElementById('color3')?.value,
						neutral: document.getElementById('color4')?.value
					},
					referenceImages: uploadedImages,
					generatedAvatar: generatedAvatar // Include the generated avatar data
				};
				
				console.log('💾 Saving avatar creation data:', {
					hasGeneratedAvatar: !!generatedAvatar,
					generatedAvatarFilename: generatedAvatar?.filename,
					referenceImagesCount: uploadedImages.length,
					referenceImages: uploadedImages
				});
				
				// Show user feedback about what's being saved
				if (generatedAvatar) {
					console.log('✅ Generated avatar will be saved with sticker group');
				} else {
					console.log('ℹ️ No generated avatar to save (user can generate one later)');
				}
				
				// Update centralized state and request unified save
				window.dispatchEvent(new CustomEvent('sectionDataUpdated', { detail: {
					avatarCreation: {
						description: formData.avatarDescription,
						personality: formData.personality,
						colorPalette: formData.colorPalette,
						referenceImages: formData.referenceImages,
						generatedAvatar: formData.generatedAvatar
					}
				}}));
				window.dispatchEvent(new CustomEvent('requestSave'));

				// Store in session storage
				sessionStorage.setItem('avatarCreation', JSON.stringify(formData));
				
				// Emit custom event to move to next step
				window.dispatchEvent(new CustomEvent('stepCompleted', { 
					detail: { step: 'avatarCreation', data: formData } 
				}));
			});
		}

		// Go back button
		const goBackButton = document.getElementById('goBackAvatarCreation');
		if (goBackButton) {
			goBackButton.addEventListener('click', function() {
				// Emit custom event to go back
				window.dispatchEvent(new CustomEvent('goBack', { 
					detail: { fromStep: 'avatarCreation' } 
				}));
			});
		}

		// Reference Images functionality
		let uploadedImages = [];
		let generatedAvatar = null; // Store the generated avatar data
		const MAX_IMAGES = 3;
		const API_BASE = 'http://localhost:8002';

		// File upload handling
		const uploadArea = document.getElementById('uploadArea');
		const fileInput = document.getElementById('fileInput');
		const uploadedImagesContainer = document.getElementById('uploadedImages');
		const imageList = document.getElementById('imageList');
		const uploadProgress = document.getElementById('uploadProgress');
		const progressBar = document.getElementById('progressBar');
		const progressText = document.getElementById('progressText');

		// Click to upload
		uploadArea.addEventListener('click', () => {
			if (uploadedImages.length < MAX_IMAGES) {
				fileInput.click();
			}
		});

		// Drag and drop
		uploadArea.addEventListener('dragover', (e) => {
			e.preventDefault();
			uploadArea.classList.add('border-indigo-500', 'bg-indigo-50');
		});

		uploadArea.addEventListener('dragleave', (e) => {
			e.preventDefault();
			uploadArea.classList.remove('border-indigo-500', 'bg-indigo-50');
		});

		uploadArea.addEventListener('drop', (e) => {
			e.preventDefault();
			uploadArea.classList.remove('border-indigo-500', 'bg-indigo-50');
			
			const files = Array.from(e.dataTransfer.files);
			handleFiles(files);
		});

		// File input change
		fileInput.addEventListener('change', (e) => {
			const files = Array.from(e.target.files);
			handleFiles(files);
		});

		async function handleFiles(files) {
			const remainingSlots = MAX_IMAGES - uploadedImages.length;
			const filesToProcess = files.slice(0, remainingSlots);

			if (filesToProcess.length === 0) {
				alert(`You can only upload up to ${MAX_IMAGES} images.`);
				return;
			}

			for (const file of filesToProcess) {
				await uploadImage(file);
			}
		}

		async function uploadImage(file) {
			// Validate file
			const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/svg+xml'];
			if (!allowedTypes.includes(file.type)) {
				alert('Invalid file type. Only JPG, PNG, and SVG are allowed.');
				return;
			}

			if (file.size > 10 * 1024 * 1024) {
				alert('File too large. Maximum size is 10MB.');
				return;
			}

			// Show progress
			uploadProgress.classList.remove('hidden');
			progressText.textContent = `Uploading ${file.name}...`;

			try {
				const formData = new FormData();
				formData.append('image', file);

				const uploadUrl = `${API_BASE}/reference-images`;
				console.log('Uploading to:', uploadUrl);
				console.log('API_BASE:', API_BASE);

				const response = await fetch(uploadUrl, {
					method: 'POST',
					body: formData,
					credentials: 'include'
				});

				console.log('Response status:', response.status);
				console.log('Response headers:', Object.fromEntries(response.headers.entries()));

				if (!response.ok) {
					const responseText = await response.text();
					console.log('Error response text:', responseText);
					
					try {
						const error = JSON.parse(responseText);
						throw new Error(error.error || 'Upload failed');
					} catch (parseError) {
						throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
					}
				}

				const result = await response.json();
				
				// Add to uploaded images
				const imageData = {
					filename: result.filename,
					url: result.url,
					name: file.name,
					size: file.size,
					type: file.type
				};
				console.log('📸 Adding uploaded image:', imageData);
				uploadedImages.push(imageData);

				// Update UI
				updateImageList();
				updateUploadArea();

			} catch (error) {
				console.error('Upload error:', error);
				alert(`Upload failed: ${error.message}`);
			} finally {
				uploadProgress.classList.add('hidden');
			}
		}

		function updateImageList() {
			if (uploadedImages.length === 0) {
				uploadedImagesContainer.classList.add('hidden');
				return;
			}

			uploadedImagesContainer.classList.remove('hidden');
			imageList.innerHTML = '';

			uploadedImages.forEach((image, index) => {
				console.log(`🖼️ Displaying image ${index}:`, {
					name: image.name,
					size: image.size,
					sizeInMB: (image.size / 1024 / 1024).toFixed(1),
					url: image.url
				});
				
				const imageItem = document.createElement('div');
				imageItem.className = 'flex items-center gap-3 p-3 bg-gray-50 rounded-lg';
				imageItem.innerHTML = `
					<img src="${image.url}" alt="${image.name}" class="w-12 h-12 object-cover rounded-lg" />
					<div class="flex-1 min-w-0">
						<p class="text-sm font-medium text-gray-900 truncate">${image.name}</p>
						<p class="text-xs text-gray-500">${(image.size / 1024 / 1024).toFixed(1)} MB</p>
					</div>
					<button type="button" class="text-red-500 hover:text-red-700 p-1" onclick="removeImage(${index})">
						<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
						</svg>
					</button>
				`;
				imageList.appendChild(imageItem);
			});
		}

		function updateUploadArea() {
			if (uploadedImages.length >= MAX_IMAGES) {
				uploadArea.classList.add('opacity-50', 'cursor-not-allowed');
				uploadArea.querySelector('p').textContent = 'Maximum 3 images uploaded';
			} else {
				uploadArea.classList.remove('opacity-50', 'cursor-not-allowed');
				uploadArea.querySelector('p').textContent = 'Drag & drop images here';
			}
		}

		async function removeImage(index) {
			const image = uploadedImages[index];
			
			try {
				// Delete from server
				const response = await fetch(`${API_BASE}/reference-images?filePath=${encodeURIComponent(image.filename)}`, {
					method: 'DELETE',
					credentials: 'include'
				});

				if (!response.ok) {
					throw new Error('Failed to delete image from server');
				}

				// Remove from local array
				uploadedImages.splice(index, 1);
				
				// Update UI
				updateImageList();
				updateUploadArea();

			} catch (error) {
				console.error('Delete error:', error);
				alert(`Failed to delete image: ${error.message}`);
			}
		}

		// Make removeImage globally available
		window.removeImage = removeImage;

		// Populate from centralized state after StickerCreator load
		window.addEventListener('groupDataLoaded', () => {
			const state = (window).stickitGroupState || {};
			const ac = state?.input?.avatarCreation || {};
			const descEl = document.getElementById('avatarCreationDescription');
			if (descEl instanceof HTMLTextAreaElement && typeof ac.description === 'string') descEl.value = ac.description;
			// Personality selection
			const personalityButtons = document.querySelectorAll('[data-personality]');
			if (typeof ac.personality === 'string') {
				personalityButtons.forEach(btn => {
					btn.classList.remove('border-indigo-500', 'bg-indigo-50', 'text-indigo-700', 'shadow-md');
					btn.classList.add('border-gray-200', 'text-gray-600');
					if (btn instanceof HTMLElement && btn.dataset.personality === ac.personality) {
						btn.classList.add('border-indigo-500', 'bg-indigo-50', 'text-indigo-700', 'shadow-md');
						btn.classList.remove('border-gray-200', 'text-gray-600');
					}
				});
			}
			// Colors
			const palette = ac.colorPalette || {};
			const color1 = document.getElementById('color1');
			const color2 = document.getElementById('color2');
			const color3 = document.getElementById('color3');
			const color4 = document.getElementById('color4');
			if (color1 instanceof HTMLInputElement && typeof palette.primary === 'string') color1.value = palette.primary;
			if (color2 instanceof HTMLInputElement && typeof palette.secondary === 'string') color2.value = palette.secondary;
			if (color3 instanceof HTMLInputElement && typeof palette.accent === 'string') color3.value = palette.accent;
			if (color4 instanceof HTMLInputElement && typeof palette.neutral === 'string') color4.value = palette.neutral;
			
			
			// Load reference images if they exist
			if (Array.isArray(ac.referenceImages)) {
				console.log('🔄 Loading reference images from state:', ac.referenceImages);
				uploadedImages = ac.referenceImages;
				updateImageList();
				updateUploadArea();
			} else {
				console.log('ℹ️ No reference images found in state');
			}
			
			// Load generated avatar if it exists
			if (ac.generatedAvatar && ac.generatedAvatar.url) {
				generatedAvatar = ac.generatedAvatar;
				console.log('🔄 Restored generated avatar:', generatedAvatar);
				
				// Update the avatar preview image
				const avatarImage = document.querySelector('.w-24.h-24.rounded-xl');
				if (avatarImage) {
					avatarImage.src = generatedAvatar.url;
					avatarImage.alt = 'Generated Avatar';
					console.log('🖼️ Avatar preview restored with generated image');
				}
			}
		});
	});
</script>
